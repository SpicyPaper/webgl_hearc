<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>webgl_labo1</title>
  </head>
  <body onload="initWebGL()">
    <canvas id="webgl-canvas" width="666" height="666">
      Your Browser does not support HTML5.
    </canvas>
  </body>
  <script src="js/gl-matrix-min.js"></script>
  <script src="js/webglTools.js"></script>
  <script src="js/spike.js"></script>
  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aColor;
    uniform mat4 uTMatrix;
    uniform mat4 uWMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    varying vec4 vColor;
    void main(void) {
      vColor = aColor;
      gl_Position = uPMatrix * uMVMatrix * uWMatrix * uTMatrix * vec4(aVertexPosition, 1.0);
    }
  </script>
  <script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
      precision highp float;
    #endif
    varying vec4 vColor;
    void main(void) {
      gl_FragColor = vColor;
    }
  </script>
  <script type="text/javascript">
    // Parameters of the Application
    const SQUARENSPIKESBY2 = 10;  // Square Number of spikes /2 => SQUARENSPIKESBY2 = SquareRoot(nbSpikes)/2 -> 5 => 100
    const SMIN = 0.6;    // Minimum scale
    const SMAX = 1;      // Maximum scale
    const DSMIN = 0.003; // Min rate of change
    const DSMAX = 0.005; // Max rate of change
    var spikes = [];     // Array of spikes

    // Scene
    var vertexBuffer = undefined;
    var indexBuffer  = undefined;
    var colorBuffer  = undefined;

    var indices  = []; // JS array to store the indices of the polygon
    var vertices = []; // JS array to store the vertices of the polygon
    var colors   = []; // JS array to store the colors assigned to each vertex

    // Camera
    var mvMatrix = mat4.create(); // Model-View matrix
    var pMatrix  = mat4.create(); // projection matrix

    // transformations matrix
    var wMatrix = mat4.create();  // Apply to whole world
    var tMatrix = mat4.create();  // Used to move elements before drawing

    function initShaderParameters(prg)
    {
      prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
      glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
      prg.colorAttribute 			    = glContext.getAttribLocation(prg, "aColor");
      glContext.enableVertexAttribArray(prg.colorAttribute);
      prg.tMatrixUniform          = glContext.getUniformLocation(prg, 'uTMatrix');
      prg.wMatrixUniform          = glContext.getUniformLocation(prg, 'uWMatrix');
      prg.pMatrixUniform          = glContext.getUniformLocation(prg, 'uPMatrix');
      prg.mvMatrixUniform         = glContext.getUniformLocation(prg, 'uMVMatrix');
    }

    function initBuffers()
    {
      //spiky squared pyramide
      vertices.push(  0.0, 1.3,  0);
      vertices.push(  0.2, 0.2,  0.2);
      vertices.push( -0.2, 0.2,  0.2);
      vertices.push( -0.2, 0.2, -0.2);
      vertices.push(  0.2, 0.2, -0.2);

      let orange = [1.0, 165./255, 0.0, 1.0];
      colors.push(1.0, 1.0, 0.0, 1.0);
      colors.push(...orange.slice());
      colors.push(...orange.slice());
      colors.push(...orange.slice());
      colors.push(...orange.slice());

      indices.push(0, 1, 2, 3, 4, 1);

      vertexBuffer = getVertexBufferWithVertices(vertices);
      colorBuffer  = getVertexBufferWithVertices(colors);
      indexBuffer  = getIndexBufferWithIndices(indices);

      createSpikes();
    }

    function createSpikes()
    {
      let deltaAngle = Math.PI/SQUARENSPIKESBY2/2;
      let startAngle = Math.PI/2+deltaAngle/2;
      for(let i = 0; i < SQUARENSPIKESBY2*2; i++){
        for(let j = 0; j < SQUARENSPIKESBY2*2; j++){
          spikes.push(
    			  new Spike(
      				startAngle + i * deltaAngle,
      				deltaAngle * j,
      				Math.floor(Math.random() * SMAX * 10) / 10 + SMIN,
      				Math.floor(Math.random() * DSMAX * 1000) / 1000 + DSMIN
      			),
    			  new Spike(
      				startAngle + i * deltaAngle,
      				deltaAngle * j - Math.PI,
      				Math.floor(Math.random() * SMAX * 10) / 10 + SMIN,
      				Math.floor(Math.random() * DSMAX * 1000) / 1000 + DSMIN
      			)
          );
        }
      }
    }

    function drawScene()
    {
      glContext.clearColor(0.1, 0.1, 0.1, 1.0);
      glContext.enable(glContext.DEPTH_TEST);
      glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
      glContext.viewport(0, 0, c_width, c_height);

      mat4.perspective(pMatrix, degToRad(90), c_width / c_height, 0.1, 1000.0); // champ de vision de 90° commençant à 0.1 de la camera et jusqu'à 1000

      mat4.lookAt(mvMatrix, [0,0,-3], [0,0,0], [0,1,0]); // regarde depuis -3 en profondeur vers 0,0,0 et avec y positif en haut de l'écran

      let angle = performance.now() / 1000 / 6 * Math.PI;
      mat4.rotate(wMatrix, mat4.create(), angle, [1, 0, 1]); // rotation of the shape

      glContext.uniformMatrix4fv(prg.wMatrixUniform, false, wMatrix);
      glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
      glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);

      glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
      glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
      glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
      glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
      glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

      for(let i = 0; i < spikes.length; i++)
      {
        spikes[i].update();
        spikes[i].draw();
      }
    }

    function initWebGL()
    {
      glContext = getGLContext("webgl-canvas");
      initProgram();
      initBuffers();
      renderLoop();
    }
  </script>
</html>
